--
-- Test BEFORE/AFTER feature in RETURNING statements
CREATE TABLE foo (
		bar1 INTEGER,
		bar2 TEXT
		);
INSERT INTO foo VALUES (1, 'x'),(2,'y');
UPDATE foo SET bar1=bar1+1 RETURNING before.*, bar1, bar2;
 bar1 | bar2 | bar1 | bar2 
------+------+------+------
    1 | x    |    2 | x
    2 | y    |    3 | y
(2 rows)

UPDATE foo SET bar1=bar1-1 RETURNING after.bar1, before.bar1*2;
 bar1 | ?column? 
------+----------
    1 |        4
    2 |        6
(2 rows)

UPDATE foo SET bar1=bar1+1, bar2=bar2 || 'z' RETURNING before.*, after.*;
 bar1 | bar2 | bar1 | bar2 
------+------+------+------
    1 | x    |    2 | xz
    2 | y    |    3 | yz
(2 rows)

-- check single after
UPDATE foo SET bar1=bar1+1, bar2=bar2 || 'a' RETURNING after.*;
 bar1 | bar2 
------+------
    3 | xza
    4 | yza
(2 rows)

-- check single before
UPDATE foo SET bar1=bar1+1, bar2=bar2 || 'b' RETURNING before.*;
 bar1 | bar2 
------+------
    3 | xza
    4 | yza
(2 rows)

-- it should fail
UPDATE foo SET bar1=bar1+before.bar1 RETURNING before.*;
ERROR:  missing FROM-clause entry for table "before"
LINE 1: UPDATE foo SET bar1=bar1+before.bar1 RETURNING before.*;
                                 ^
UPDATE foo SET bar1=bar1+after.bar1 RETURNING after.*;
ERROR:  missing FROM-clause entry for table "after"
LINE 1: UPDATE foo SET bar1=bar1+after.bar1 RETURNING after.*;
                                 ^
-- test before/after aliases
UPDATE foo AS before SET bar1=bar1+1 RETURNING before.*,after.*;
 bar1 | bar2 | bar1 | bar2 
------+------+------+------
    5 | xzab |    5 | xzab
    6 | yzab |    6 | yzab
(2 rows)

UPDATE foo AS after SET bar1=bar1-1 RETURNING before.*,after.*;
 bar1 | bar2 | bar1 | bar2 
------+------+------+------
    5 | xzab |    4 | xzab
    6 | yzab |    5 | yzab
(2 rows)

-- test inheritance
CREATE TABLE foo2 (bar INTEGER) INHERITS(foo);
INSERT INTO foo2 VALUES (1,'b',5);
UPDATE foo2 SET bar1=bar1*2, bar=bar1+5, bar2=bar1::text || bar::text RETURNING before.*, after.*, *;
 bar1 | bar2 | bar | bar1 | bar2 | bar | bar1 | bar2 | bar 
------+------+-----+------+------+-----+------+------+-----
    1 | b    |   5 |    2 | 15   |   6 |    2 | 15   |   6
(1 row)

-- check views
CREATE VIEW view_foo AS SELECT * FROM foo;
UPDATE foo SET bar1=bar1+1 RETURNING before.*, bar1, bar2;
 bar1 | bar2 | bar1 | bar2 
------+------+------+------
    4 | xzab |    5 | xzab
    5 | yzab |    6 | yzab
    2 | 15   |    3 | 15
(3 rows)

CREATE TABLE foo3 (bar1 INTEGER, bar4 FLOAT);
INSERT INTO foo2 VALUES (2, 'asdf', 33);
INSERT INTO foo3 VALUES (2, 7.77);
CREATE VIEW view_join AS SELECT f2.*, f3.bar1 AS f1bar1, f3.bar4 FROM foo2 f2 
JOIN foo3 f3 ON f2.bar1 = f3.bar1;
UPDATE view_join SET bar1=bar1+5, bar2=bar2||'join', bar=bar1*2, bar4=7 RETURNING before.*, after.*;
ERROR:  cannot update view "view_join"
DETAIL:  Views that do not select from a single table or view are not automatically updatable.
HINT:  To make the view updatable, provide an unconditional ON UPDATE DO INSTEAD rule or an INSTEAD OF UPDATE trigger.
-- check triggers
CREATE FUNCTION returning_trig() returns trigger as $$
BEGIN
NEW.bar1 = NEW.bar1*NEW.bar1; 
RETURN NEW;
END; $$ language plpgsql;
DROP TABLE foo2 CASCADE;
NOTICE:  drop cascades to view view_join
CREATE TRIGGER bef_foo BEFORE UPDATE ON foo FOR EACH ROW EXECUTE PROCEDURE returning_trig();
UPDATE foo SET bar1=bar1+1, bar2=bar2 || 'z' RETURNING before.*, after.*, *;
 bar1 | bar2 | bar1 | bar2  | bar1 | bar2  
------+------+------+-------+------+-------
    5 | xzab |    6 | xzabz |   36 | xzabz
    6 | yzab |    7 | yzabz |   49 | yzabz
(2 rows)

DROP TABLE foo CASCADE;
NOTICE:  drop cascades to view view_foo
DROP TABLE foo3 CASCADE;
CREATE TABLE t1 (id serial, x int, y int, z int);
CREATE TABLE t2 (id serial, x int, y int, z int);
INSERT INTO t1 VALUES (DEFAULT,1,2,3);
INSERT INTO t1 VALUES (DEFAULT,4,5,6);
-- check WITH statement 
WITH foo AS (UPDATE t1 SET x=x*2, y=y+1, z=x+y+z RETURNING BEFORE.x, BEFORE.y, AFTER.z) INSERT INTO t2 (x,y,z) SELECT x, y, z FROM foo RETURNING *;
 id | x | y | z  
----+---+---+----
  1 | 1 | 2 |  6
  2 | 4 | 5 | 15
(2 rows)

-- check UPDATE ... FROM statement
UPDATE t2 SET x = t1.x+2 FROM t1 WHERE t2.id=t1.id RETURNING after.x, before.x;
 x  | x 
----+---
  4 | 1
 10 | 4
(2 rows)

UPDATE t2 SET x = t1.x*2 FROM t1 WHERE t2.id=t1.id RETURNING after.*, before.*;
 id | x  | y | z  | id | x  | y | z  
----+----+---+----+----+----+---+----
  1 |  4 | 2 |  6 |  1 |  4 | 2 |  6
  2 | 16 | 5 | 15 |  2 | 10 | 5 | 15
(2 rows)

DROP TABLE t1;
DROP TABLE t2;
